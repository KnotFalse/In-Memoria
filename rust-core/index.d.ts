/* auto-generated by NAPI-RS */
/* eslint-disable */
/** Predictor for suggesting coding approaches based on patterns and context */
export declare class ApproachPredictor {
  constructor()
  /** Predict the best approach for a given problem description */
  predictApproach(problemDescription: string, contextData?: string | undefined | null): ApproachPrediction
}

/** Blueprint analyzer for detecting project structure */
export declare class BlueprintAnalyzer {
  constructor()
  /** Detect entry points using AST-based analysis and pattern matching */
  static detectEntryPoints(path: string, frameworks: Array<FrameworkInfo>): Promise<Array<EntryPoint>>
  /** Map key directories in the project */
  static mapKeyDirectories(path: string): Promise<Array<KeyDirectory>>
  /** Build feature map for the project */
  static buildFeatureMap(path: string): Promise<Array<FeatureMap>>
}

/** Analyzer for calculating code complexity metrics */
export declare class ComplexityAnalyzer {
  constructor()
}

/** Analyzer for detecting frameworks and libraries used in a codebase */
export declare class FrameworkDetector {
  constructor()
  /** Detect frameworks used in a codebase */
  static detectFrameworks(path: string): Promise<Array<FrameworkInfo>>
}

/** Analyzer for detecting implementation patterns (design patterns) */
export declare class ImplementationPatternAnalyzer {
  constructor()
}

/** Analyzer for detecting and learning naming conventions */
export declare class NamingPatternAnalyzer {
  constructor()
}

/** Manages tree-sitter parsers for different programming languages */
export declare class ParserManager {

}

/** Legacy PatternLearner for backwards compatibility */
export declare class PatternLearner {
  constructor()
  /**
   * Learn patterns from an entire codebase
   *
   * # Safety
   * This function is marked unsafe for NAPI compatibility. It performs file system operations
   * and pattern analysis that are inherently safe but marked unsafe for JavaScript interop.
   */
  learnFromCodebase(path: string): Promise<Array<Pattern>>
  /**
   * Extract patterns from a specific path
   *
   * # Safety
   * This function is marked unsafe for NAPI compatibility. It performs file system operations
   * and pattern analysis that are inherently safe but marked unsafe for JavaScript interop.
   */
  extractPatterns(path: string): Promise<Array<Pattern>>
  /**
   * Analyze file changes to identify patterns (original signature)
   *
   * # Safety
   * This function is marked unsafe due to NAPI bindings requirements.
   * It should only be called from properly initialized JavaScript contexts.
   */
  analyzeFileChange(changeData: string): Promise<PatternAnalysisResult>
  /**
   * Find patterns relevant to a given problem description (original signature)
   *
   * # Safety
   * This function is marked unsafe due to NAPI bindings requirements.
   * It should only be called from properly initialized JavaScript contexts.
   */
  findRelevantPatterns(problemDescription: string, currentFile?: string | undefined | null, selectedCode?: string | undefined | null): Promise<Array<Pattern>>
  /**
   * Predict coding approach based on problem description and context (original signature)
   *
   * # Safety
   * This function is marked unsafe due to NAPI bindings requirements.
   * It should only be called from properly initialized JavaScript contexts.
   */
  predictApproach(problemDescription: string, context: Record<string, string>): Promise<ApproachPrediction>
  /**
   * Learn from analysis data
   *
   * # Safety
   * This function is marked unsafe for NAPI compatibility. It performs data parsing and
   * learning operations that are inherently safe but marked unsafe for JavaScript interop.
   */
  learnFromAnalysis(analysisData: string): Promise<boolean>
  /**
   * Update pattern learner from change data (from original implementation)
   *
   * # Safety
   * This function is marked unsafe for NAPI compatibility. It performs data parsing and
   * pattern update operations that are inherently safe but marked unsafe for JavaScript interop.
   */
  updateFromChange(changeData: string): Promise<boolean>
}

/** Core learning engine that orchestrates pattern discovery across all domains */
export declare class PatternLearningEngine {
  constructor()
  /**
   * Learn patterns from an entire codebase
   *
   * # Safety
   * This function is marked unsafe for NAPI compatibility. It performs file system operations
   * and pattern analysis that are inherently safe but marked unsafe for JavaScript interop.
   */
  learnFromCodebase(path: string): Promise<Array<Pattern>>
  /**
   * Learn from file changes (incremental learning)
   *
   * # Safety
   * This function is marked unsafe for NAPI compatibility. It performs pattern analysis
   * operations that are inherently safe but marked unsafe for JavaScript interop.
   */
  learnFromChanges(oldContent: string, newContent: string, filePath: string, language: string): Promise<Array<Pattern>>
  /**
   * Learn from analysis data (JSON format)
   *
   * # Safety
   * This function is marked unsafe for NAPI compatibility. It performs data parsing and
   * learning operations that are inherently safe but marked unsafe for JavaScript interop.
   */
  learnFromAnalysis(analysisData: string): Promise<boolean>
  /** Get comprehensive analysis of learned patterns */
  analyzePatterns(concepts: Array<SemanticConcept>): PatternAnalysisResult
  /** Predict best approach for a problem */
  predictApproach(problemDescription: string, context?: string | undefined | null): ApproachPrediction
  /**
   * Updates patterns based on file changes (from original implementation)
   *
   * # Safety
   * This function uses unsafe because it needs to interact with the Node.js runtime
   * through N-API bindings. The caller must ensure the change data is valid JSON.
   */
  updateFromChange(changeData: string): Promise<boolean>
}

/** Analyzer for learning and discovering relationships between code concepts */
export declare class RelationshipLearner {
  constructor()
}

/** Main semantic analyzer that orchestrates concept extraction across languages */
export declare class SemanticAnalyzer {
  constructor()
  /**
   * Analyzes an entire codebase for semantic concepts and patterns
   *
   * # Safety
   * This function is marked unsafe for NAPI compatibility. It performs file system operations
   * and language parsing that are inherently safe but marked unsafe for JavaScript interop.
   */
  analyzeCodebase(path: string): Promise<CodebaseAnalysisResult>
  /**
   * Analyzes the content of a specific file for semantic concepts
   *
   * # Safety
   * This function is marked unsafe for NAPI compatibility. It performs language parsing
   * operations that are inherently safe but marked unsafe for JavaScript interop.
   */
  analyzeFileContent(filePath: string, content: string): Promise<Array<SemanticConcept>>
  /**
   * Learns semantic concepts from analyzing an entire codebase
   *
   * # Safety
   * This function is marked unsafe for NAPI compatibility. It performs file system operations
   * and language parsing that are inherently safe but marked unsafe for JavaScript interop.
   */
  learnFromCodebase(path: string): Promise<Array<SemanticConcept>>
  /**
   * Updates the analyzer's internal state from analysis data (from original implementation)
   *
   * # Safety
   * This function uses unsafe because it needs to interact with the Node.js runtime
   * through N-API bindings. The caller must ensure the analysis data is valid JSON.
   */
  updateFromAnalysis(analysisData: string): Promise<boolean>
  /** Get concept relationships for a specific concept ID (from original implementation) */
  getConceptRelationships(conceptId: string): Array<string>
}

/** Analyzer for detecting architectural and structural patterns */
export declare class StructuralPatternAnalyzer {
  constructor()
}

/** Prediction of coding approach based on patterns */
export interface ApproachPrediction {
  approach: string
  confidence: number
  reasoning: string
  patterns: Array<string>
  complexity: string
}

export interface AstNode {
  nodeType: string
  text: string
  startLine: number
  endLine: number
  startColumn: number
  endColumn: number
  children: Array<AstNode>
}

export interface CodebaseAnalysisResult {
  languages: Array<string>
  frameworks: Array<string>
  complexity: ComplexityMetrics
  concepts: Array<SemanticConcept>
}

export interface ComplexityMetrics {
  cyclomaticComplexity: number
  cognitiveComplexity: number
  functionCount: number
  classCount: number
  fileCount: number
  avgFunctionsPerFile: number
  avgLinesPerConcept: number
  maxNestingDepth: number
}

/** Entry point information */
export interface EntryPoint {
  entryType: string
  filePath: string
  framework?: string
  confidence: number
}

/** Feature mapping information */
export interface FeatureMap {
  id: string
  featureName: string
  primaryFiles: Array<string>
  relatedFiles: Array<string>
  dependencies: Array<string>
}

/** Framework detection results */
export interface FrameworkInfo {
  name: string
  version?: string
  confidence: number
  evidence: Array<string>
}

export declare function initCore(): string

/** Key directory information */
export interface KeyDirectory {
  path: string
  dirType: string
  fileCount: number
}

export interface LineRange {
  start: number
  end: number
}

export interface ParseResult {
  language: string
  tree: AstNode
  errors: Array<string>
  symbols: Array<symbol>
}

/** Core pattern representation */
export interface Pattern {
  id: string
  patternType: string
  description: string
  frequency: number
  confidence: number
  examples: Array<PatternExample>
  contexts: Array<string>
}

/** Result of pattern analysis */
export interface PatternAnalysisResult {
  detected: Array<string>
  violations: Array<string>
  recommendations: Array<string>
  learned?: Array<Pattern>
}

/** Example of a pattern occurrence */
export interface PatternExample {
  code: string
  filePath: string
  lineRange: LineRange
}

export interface SemanticConcept {
  id: string
  name: string
  conceptType: string
  confidence: number
  filePath: string
  lineRange: LineRange
  relationships: Record<string, string>
  metadata: Record<string, string>
}

export interface Symbol {
  name: string
  symbolType: string
  line: number
  column: number
  scope: string
}
